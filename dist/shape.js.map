{"version":3,"sources":["../src/shape.js"],"names":["Shape","shapeId","groupId","shapeData","attr","hasOwnProperty","actCol","colorLuminance","col","shape","game","s","g","transFromOriginX","transFromOriginY","createShape","hex","lum","startsWith","substr","rgb","c","i","parseInt","Math","round","min","max","toString","length","x","y","icon","factor","scale","cellSize","topRightArrow","bottomLeftArrow","bottomRightArrow","rightUpArrow","leftDownArrow","leftUpArrow","react","hor","add","polyline","ver","shift","id","stroke","strokeWidth","strokeOpacity","fill","transform","cornerPoints","cs","pointsObj","key","pointsSet","Set","Object","keys","map","points","value","push","split","Number","polygonArray","firstPoint","lastAddedPoint","splice","hasPoint","p","addNextPolygonPoint","horDir","verDir","polygonDone","console","log","px","pos","py","firstCell","grid","type","createPolygon","polygon","striped","drawReactionIcon","futureShapeCells","gridHeight","gridWidth","futureGrid","stash","activeShape","stashCount","shapeCell","nextX","nextY","getShapeAtPos","highlightObstacle","setTimeout","active","JSON","parse","stringify","couldMove","simulateMove","indicateInvalidMove","reactiveShapes","animateMove","moveAnimation","animate","mina","bounce","setAttrForActiveGroup","opacity"],"mappings":"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","file":"shape.js","sourcesContent":["class Shape {\r\n  constructor(shapeId, groupId, shapeData, attr) {\r\n    this.shapeId = shapeId;\r\n    this.groupId = groupId;\r\n    this.shapeData = shapeData;\r\n    this.attr = attr;\r\n    if (this.attr.hasOwnProperty('col'))\r\n      this.attr.actCol = this.colorLuminance(this.attr.col, 0.15); // Calculate active color\r\n\r\n    this.shape = game.s.g();\r\n\r\n    this.transFromOriginX = 0;\r\n    this.transFromOriginY = 0;\r\n\r\n    this.createShape();\r\n  }\r\n\r\n  /**\r\n   * Calculate the increase or decrease in color luminance\r\n   */\r\n  colorLuminance(hex, lum) {\r\n    if (hex.startsWith(\"#\"))\r\n      hex = hex.substr(1);\r\n\r\n    let rgb = \"#\";\r\n    let c;\r\n    for (let i = 0; i < 3; i++) {\r\n      c = parseInt(hex.substr(i * 2, 2), 16);\r\n      c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);\r\n      rgb += (\"00\" + c).substr(c.length);\r\n    }\r\n    return rgb;\r\n  }\r\n\r\n  /**\r\n   * Draw the icon indicating the shape's relation with the group\r\n   */\r\n  drawReactionIcon(x, y) {\r\n    let icon = game.s.g();\r\n    let factor = 0.75;\r\n    let scale = (game.cellSize / 120) * factor;\r\n\r\n    //let topRightArrow = [10, 50, 110, 50, 95, 35];\r\n    let topRightArrow = [95, 35, 110, 50, 10, 50]; // Revert\r\n    let bottomLeftArrow = [110, 70, 10, 70, 25, 85];\r\n    let bottomRightArrow = [10, 70, 110, 70, 95, 85];\r\n\r\n    // let rightUpArrow = [70, 110, 70, 10, 85, 25];\r\n    let rightUpArrow = [85, 25, 70, 10, 70, 110]; // Revert\r\n    let leftDownArrow = [50, 10, 50, 110, 35, 95];\r\n    let leftUpArrow = [50, 110, 50, 10, 35, 25];\r\n\r\n    if (this.attr.react.hor === -1) {\r\n      icon.add(game.s.polyline(topRightArrow));\r\n      icon.add(game.s.polyline(bottomLeftArrow));\r\n    } else {\r\n      icon.add(game.s.polyline([...topRightArrow, ...bottomRightArrow]));\r\n    }\r\n\r\n    if (this.attr.react.ver === -1) {\r\n      icon.add(game.s.polyline(rightUpArrow));\r\n      icon.add(game.s.polyline(leftDownArrow));\r\n    } else {\r\n      icon.add(game.s.polyline([...rightUpArrow, ...leftUpArrow]));\r\n    }\r\n\r\n    let shift = game.cellSize * (1 - factor) / 2;\r\n\r\n    icon.attr({\r\n      id: \"icon\",\r\n      stroke: \"#ffffff\",\r\n      strokeWidth: 5,\r\n      strokeOpacity: 1,\r\n      fill: \"none\",\r\n      transform: \"translate(\" + (x + shift) + \", \" + (y + shift) + \"), scale(\" + scale + \")\"\r\n    });\r\n\r\n    return icon;\r\n  }\r\n\r\n\r\n  /**\r\n   * Trace the polygon for all the points in the shape.\r\n   * Returns a tight convex hull.\r\n   */\r\n  createPolygon(cornerPoints) {\r\n    // Shorthand varibles\r\n    let cs = game.cellSize; // Cell width and height are always the same\r\n\r\n    // Prepare the point data\r\n    let pointsObj = {};\r\n\r\n    for (let i = 0; i < cornerPoints.length; i++) {\r\n      let key = cornerPoints[i][0] + \"_\" + cornerPoints[i][1];\r\n      if (pointsObj[key]) {\r\n        pointsObj[key]++;\r\n      } else {\r\n        pointsObj[key] = 1;\r\n      }\r\n\r\n      if (pointsObj[key] == 4)\r\n        delete pointsObj[key]; // Remove internal points (which have four instances)\r\n    }\r\n\r\n    // Make a point set from point object (removes duplicates)\r\n    let pointsSet = new Set(Object.keys(pointsObj).map(key => key));\r\n\r\n    // Convert the set of strings into an array of numbers\r\n    let points = [];\r\n    for (let value of pointsSet)\r\n      points.push(value.split(\"_\").map(Number));\r\n\r\n    // Find the polygon points of the shape\r\n    let polygonArray = [];\r\n    let firstPoint = points[0];\r\n\r\n    // Add the first point to polygon\r\n    polygonArray.push(firstPoint);\r\n    let lastAddedPoint = firstPoint;\r\n    points.splice(0, 1); // Remove the first point\r\n\r\n    // Does the points array contain this point\r\n    function hasPoint(x, y) {\r\n      for (let p of points)\r\n        if (p[0] === x && p[1] === y)\r\n          return true;\r\n      return false;\r\n    }\r\n\r\n    // Helper function used inside the loop\r\n    function addNextPolygonPoint(horDir, verDir) {\r\n      let x = lastAddedPoint[0] + horDir * cs;\r\n      let y = lastAddedPoint[1] + verDir * cs;\r\n\r\n      if (firstPoint[0] === x && firstPoint[1] === y) {\r\n        polygonDone = true;\r\n        return true;\r\n      }\r\n\r\n      // Special case if direction is up\r\n      // Do not go up if there is a cell on the left\r\n      if (verDir === -1) {\r\n        if (hasPoint(x - cs, y) && hasPoint(x - cs, y + cs))\r\n          return false;\r\n      }\r\n\r\n      for (let i = 0; i < points.length; i++) {\r\n        if (x === points[i][0] && y === points[i][1]) {\r\n          polygonArray.push(points[i]); // Next point\r\n          lastAddedPoint = points[i];\r\n          points.splice(i, 1); // Remove the added point\r\n          return true; // Found and added\r\n        }\r\n      }\r\n      return false; // Not found\r\n    }\r\n\r\n    let polygonDone = false;\r\n    let i = 0; // Counter\r\n    while (!polygonDone) {\r\n\r\n      if (++i > 50) {\r\n        if (points.length !== 0)\r\n          console.log(\"Bad Shape! Points left.\");\r\n        console.log(\"Bad Shape! Max iterations of 50 reached.\");\r\n        polygonDone = true; // Just of safety. This should never happen with correct shapes!\r\n      }\r\n\r\n      // Above\r\n      if (addNextPolygonPoint(0, -1))\r\n        continue;\r\n\r\n      // Right\r\n      if (addNextPolygonPoint(1, 0))\r\n        continue;\r\n\r\n      // Below\r\n      if (addNextPolygonPoint(0, 1))\r\n        continue;\r\n\r\n      // Right\r\n      if (addNextPolygonPoint(-1, 0))\r\n        continue;\r\n\r\n    }\r\n\r\n    /*\r\n        // Debug. Draw the points and order\r\n        for (let i = 0; i < polygonArray.length; i++) {\r\n          let circle = game.s.circle(polygonArray[i][0], polygonArray[i][1], 4);\r\n          circle.attr({\r\n            fill: \"red\"\r\n          });\r\n          let text = game.s.text(polygonArray[i][0] + 5, polygonArray[i][1] - 5, i + 1);\r\n        }\r\n    */\r\n    return polygonArray;\r\n  }\r\n\r\n  /**\r\n   * Create the level from the data\r\n   */\r\n  createShape() {\r\n    // Shorthand varibles\r\n    let cs = game.cellSize; // Cell width and height are always the same\r\n    let px = this.shapeData.pos.x;\r\n    let py = this.shapeData.pos.y;\r\n\r\n    let firstCell = false;\r\n\r\n    let cornerPoints = [];\r\n    for (let y = 0; y < this.shapeData.grid.length; y++) {\r\n      for (let x = 0; x < this.shapeData.grid[y].length; x++) {\r\n        if (this.shapeData.grid[y][x] == 1) {\r\n\r\n          if (!firstCell) {\r\n            // Draw the type/reaction icon in the first cell (top left)\r\n            firstCell = {\r\n              \"x\": x * cs + px * cs,\r\n              \"y\": y * cs + py * cs\r\n            };\r\n          }\r\n\r\n          // Top left\r\n          cornerPoints.push([\r\n            x * cs + px * cs,\r\n            y * cs + py * cs\r\n          ]);\r\n          // Top right\r\n          cornerPoints.push([\r\n            x * cs + px * cs + cs,\r\n            y * cs + py * cs\r\n          ]);\r\n          // Bottom right\r\n          cornerPoints.push([\r\n            x * cs + px * cs + cs,\r\n            y * cs + py * cs + cs\r\n          ]);\r\n          // Bottom left\r\n          cornerPoints.push([\r\n            x * cs + px * cs,\r\n            y * cs + py * cs + cs\r\n          ]);\r\n\r\n          // Add cell to internal game grid\r\n          game.grid[y + py][x + px] = {\r\n            \"groupId\": this.groupId,\r\n            \"shapeId\": this.shapeId,\r\n            \"type\": this.attr.type\r\n          };\r\n\r\n        }\r\n      }\r\n    }\r\n\r\n    let polygonArray = this.createPolygon(cornerPoints);\r\n    let polygon = game.s.polygon(polygonArray);\r\n\r\n    this.shape.add(polygon);\r\n\r\n    if (this.attr.type == \"static\")\r\n      this.shape.attr({\r\n        stroke: \"#ffffff\",\r\n        fill: game.striped\r\n      });\r\n    else if (this.attr.type == \"active\")\r\n      this.shape.attr({\r\n        stroke: \"#ffffff\",\r\n        fill: this.attr.col\r\n      });\r\n\r\n    if (this.attr.type == \"active\") {\r\n      this.shape.add(this.drawReactionIcon(firstCell.x, firstCell.y));\r\n    }\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * Simulate the move on the future game grid\r\n   * @param {integer} horDir - Horizontal direction (-1,  0 or 1).\r\n   * @param {integer} verDir - Vertical direction (-1,  0 or 1).\r\n   * @return {boolean} The move was successful\r\n   */\r\n  simulateMove(horDir, verDir) {\r\n    // Store current shape position in grid and remove from futuregrid\r\n    let futureShapeCells = [];\r\n    for (let y = 0; y < game.gridHeight; y++) {\r\n      for (let x = 0; x < game.gridWidth; x++) {\r\n        if (game.futureGrid[y][x].shapeId == this.shapeId) {\r\n          futureShapeCells.push({\r\n            \"x\": x,\r\n            \"y\": y\r\n          });\r\n\r\n          // Check if cell has another cell stash\r\n          if (!game.futureGrid[y][x].hasOwnProperty(\"stash\")) {\r\n            game.futureGrid[y][x] = 0;\r\n          } else {\r\n            // Pop the stash in the cell into the futuregrid\r\n            game.futureGrid[y][x] = {\r\n              \"groupId\": game.futureGrid[y][x].stash.groupId,\r\n              \"shapeId\": game.futureGrid[y][x].stash.shapeId\r\n            };\r\n            game.activeShape.stashCount--;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Try putting the shape in a new position on the futuregrid\r\n    for (let shapeCell of futureShapeCells) {\r\n\r\n      let nextX = shapeCell.x + horDir;\r\n      let nextY = shapeCell.y + verDir;\r\n\r\n      if ((nextX < 0) || (nextX >= game.gridWidth) || (nextY < 0) || (nextY >= game.gridHeight))\r\n        return false; // Cell is out of bounds\r\n\r\n      if (game.futureGrid[nextY][nextX] === 0) {\r\n        game.futureGrid[nextY][nextX] = {\r\n          \"groupId\": this.groupId,\r\n          \"shapeId\": this.shapeId\r\n        };\r\n      } else if ((game.futureGrid[nextY][nextX].groupId === this.groupId) &&\r\n        ((horDir !== 0 && this.attr.react.hor === 1) || (verDir !== 0 && this.attr.react.ver === 1))\r\n      ) {\r\n        // If collision with own shape group, stash the cell in current position\r\n        // Only if shape is not going in opposite direction\r\n        game.futureGrid[nextY][nextX].stash = {\r\n          \"groupId\": this.groupId,\r\n          \"shapeId\": this.shapeId\r\n        };\r\n        game.activeShape.stashCount++;\r\n        // Allow the move for now. Stash should be empty at the end of the movement simulation\r\n      } else {\r\n        let shape = game.getShapeAtPos(nextX, nextY);\r\n        if (shape)\r\n          this.highlightObstacle(shape.shape);\r\n        else\r\n          this.highlightObstacle(this.shape);\r\n\r\n        return false; // Shape can not be moved to this position on the future grid\r\n      }\r\n    }\r\n\r\n    return true; // Shape was successfully moved to new position on the future grid\r\n  }\r\n\r\n  highlightObstacle(shape) {\r\n    shape.attr({\r\n      stroke: \"#FF2D00\"\r\n    });\r\n    // Return it back to normal\r\n    setTimeout(function() {\r\n      shape.attr({\r\n        stroke: \"#ffffff\"\r\n      });\r\n    }, 1000);\r\n  }\r\n\r\n  /**\r\n   * Move the shape in some direction\r\n   * @param {integer} horDir - Horizontal direction (-1,  0 or 1).\r\n   * @param {integer} verDir - Vertical direction (-1,  0 or 1).\r\n   * @param {boolean} active - Is this is active shape (or reactive for false)\r\n   * @return {boolean} moved - Was the move made\r\n   */\r\n  move(horDir, verDir, active) {\r\n\r\n    if (active) {\r\n      // The active shape \"deep\" copies the current game grid into the future game grid\r\n      game.futureGrid = JSON.parse(JSON.stringify(game.grid)); // A lot faster than jquery extend\r\n\r\n      this.stashCount = 0; // Stash count for cell collision in the same group\r\n\r\n      let couldMove = this.simulateMove(horDir, verDir); // Simulate move for the  active shape\r\n      if (!couldMove) {\r\n        this.indicateInvalidMove();\r\n        return false; // No need to do more if active shape can't move\r\n      }\r\n\r\n      // Simulate moves for reactive shapes\r\n      for (let shape of game.reactiveShapes) {\r\n        couldMove = shape.simulateMove(this.attr.react.hor * horDir, this.attr.react.ver * verDir);\r\n        if (!couldMove) {\r\n          shape.indicateInvalidMove();\r\n          return false; // Reactive shape can't move. No need to continue\r\n        }\r\n      }\r\n\r\n      if (this.stashCount > 0) {\r\n        this.indicateInvalidMove();\r\n        this.highlightObstacle(this.shape);\r\n        return false; // Should not be any left over stashed cells if the move was successful\r\n      }\r\n\r\n      // The future game grid is valid and can be the current game grid\r\n      game.grid = game.futureGrid;\r\n    }\r\n\r\n    // Everything looks good. Animate the movements\r\n    this.animateMove(horDir, verDir);\r\n    for (let shape of game.reactiveShapes)\r\n      shape.animateMove(this.attr.react.hor * horDir, this.attr.react.ver * verDir);\r\n\r\n    return true; // Move was successful\r\n\r\n  }\r\n\r\n  /**\r\n   * Animate the move\r\n   * @param {integer} horDir - Horizontal direction (-1,  0 or 1).\r\n   * @param {integer} verDir - Vertical direction (-1,  0 or 1).\r\n   */\r\n  animateMove(horDir, verDir) {\r\n    // Move the shape on the game board\r\n    this.transFromOriginX += horDir * game.cellSize;\r\n    this.transFromOriginY += verDir * game.cellSize;\r\n\r\n    if (game.moveAnimation === 0)\r\n      this.shape.attr({\r\n        transform: 'translate(' + this.transFromOriginX + ', ' + this.transFromOriginY + ')'\r\n      }); // Instant (no animation)\r\n    else if (game.moveAnimation === 1)\r\n      this.shape.animate({\r\n        transform: 'translate(' + this.transFromOriginX + ', ' + this.transFromOriginY + ')'\r\n      }, 50); // Fast\r\n    else\r\n      this.shape.animate({\r\n        transform: 'translate(' + this.transFromOriginX + ', ' + this.transFromOriginY + ')'\r\n      }, 200, mina.bounce); // Bounce\r\n\r\n  }\r\n\r\n  /**\r\n  Indicate that the move is invalid\r\n  */\r\n  indicateInvalidMove() {\r\n    game.setAttrForActiveGroup({\r\n      opacity: 0.5\r\n    }); // Show all shapes in group disabled\r\n  }\r\n\r\n}\r\n"]}